### 1.Two Sum

```
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        d = {}
        for i in range(len(nums)):
            if target - nums[i] in d:
                return [d[target - nums[i]], i]
            d[nums[i]] = i
        return [-1, -1]
```

通过使用map 做到 时间复杂度 O(n) 

---

### 2.  Add Two Numbers

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(-1)
        curr = dummy
        carry = 0
        while l1 or l2:
            a = l1.val if l1 else 0
            b = l2.val if l2 else 0
            sum_ = a + b + carry
            digit = sum_ % 10
            carry = sum_ // 10
            curr.next = ListNode(digit)
            curr = curr.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        if carry:
            curr.next = ListNode(carry)
            curr = curr.next
        return dummy.next
```

给两个 listNode 相加 1->2->3 + 9 = 321 + 9 

需要考虑到的地方有： 

1. 长度不同， 所以while条件用的是or 然后如果某一个listNode 已经loop完了 直接变成0 即可

2. carry 在两个ListNode都loop完的情况下 可能为1 需要把这个carry放在头部

---

### 3. Longest Substring Without Repeating Characters

```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l, res = 0, 0
        d = {}
        for r in range(len(s)):
            char = s[r]
            if char in d:
                l = max(l, d[char]+1)
            d[char] = r
            res = max(res, r-l+1)
        return res
```

用到map 去储存当前这个char的index 

1. 如果发现char 出现过即map里面有， 说明发现了repeating， 这个时候需要把left变到之前的char出现位置的后面一位，以保证left到right没有repeat

   **Note**: l = max(l, d[char]+1), 要保证left一直是向前的，不能退回到之前的位置

   ```
   abba
   1. d = {a : 0}, start = 0
   2. d = {a: 0, b : 1}, start = 0
   3. d = {a: 0, b : 2}, start = max(0, d[b] + 1) = max(0, 2) = 2
   4. d = {a: 3, b : 2}
   without max: start = d[a] + 1 = 1
   with max: start = max(2, d[a] + 1) = 2
   choose the right a not the previous a
   ```

   

2. char没出现过，d[char] = r

3. l 相当与一个最左index 新的l不能小于他 不能往回走

---

### 4. Median of Two Sorted Arrays (Hard)

```
class Solution:
    def findMedianSortedArrays(self, a: List[int], b: List[int]) -> float:
        m, n = len(a), len(b)
        if m > n:
            m, n, a, b = n, m, b, a
        size = m + n
        # one array is empty
        if m == 0:
            if n % 2 == 1:
                return b[n//2] 
            else:
                return (b[n//2-1]+b[n//2]) / 2
  			# binary search to shorter array
        l, r = 0, m      
        while l <= r:
            i = (l+r) // 2                     # a's cut position
            j = (size+1) // 2 - i              # b's cut position, determined by i
            
            # two array divided into two parts respectively
            # a[0:i - 1] | a[i:]
            # b[0:j - 1] | b[j:]
            # valid condition: a[i - 1] <= b[j] and b[j - 1] <= a[i]
            
            if i > 0 and a[i-1] > b[j]:
             # i too large
                r = i - 1
            elif i < m and b[j-1] > a[i]:
            # i too small
                l = i + 1
            else:
                if i == 0:
                    left = b[j-1]
                elif j == 0:
                    left = a[i-1]
                else:
                    left = max(a[i-1], b[j-1])
                
                if i == m:
                    right = b[j]
                elif j == n:
                    right = a[i]
                else:
                    right = min(a[i], b[j])
                if size % 2 == 1:
                    return left
                else:
                    return (left + right) / 2
```

这道题难点是要求 O(log(m+n)) 所以需要用到binary search

保证a最短是因为 对a进行二分搜索 所以imin = 0, imax = len(a )

---

### 5. Longest Palindromic Substring

```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ""
        for i in range(len(s)):
            temp = self.helper(s, i, i)
            #odd cases "aba"
            if len(temp) > len(res):
                res = temp
            #even cases "abba"
            temp = self.helper(s, i, i+1)
            if len(temp) > len(res):
                res = temp
        return res
    
    def helper(self, s, l, r):
        while l >= 0 and r < len(s):
            if s[l] == s[r]:
                l -= 1
                r += 1
            else:
                break
        return s[l+1:r]
```

worse case是到O(n^2)，目前最优解，从中间向两边扩散

---

### 6. ZigZag Conversion

```
class Solution:
    def convert(self, s: str, nRows: int) -> str:
        if nRows == 1 or nRows > len(s):
            return s
        
        i, step = 0, 1
        res = [''] * nRows
        for c in s:
            res[i] += c
            if i == 0:
                step = 1
            elif i == nRows - 1:
                step = -1
            i += step
        return ''.join(res)
```

什么是ZigZag 给String paypalishiring, nrows = 4

```
P     I    N
A   L S  I G
Y A   H R
P     I
```

所以当index 到了nrows - 1， 比如到了 3 下一次index就变成了2 也就是把第5个字母a放到了之前放到了第三排（index=3）

i == 0的时候要把step变回1， 相当与递减到row 0 后 开始递增

---

### 7. Reverse Integer

```
class Solution:
    def reverse(self, x: int) -> int:
        if x == 0:
            return 0
        sign = 1 if x > 0 else -1
        x = abs(x)
        step = 1
        res = []
        while x > 0:
            digit = x % 10
            res.append(digit)
            x //= 10
        res = int(''.join(str(i) for i in res))
        res *= sign
        if -2**31 <= res < 2**31-1:
            return res
        return 0
```

---

### 8.String to Integer (atoi)

```
class Solution:
    def myAtoi(self, s: str) -> int:
        # s is empty
        if not s:
            return 0
        # s contains space and remove space lead to empty
        s = s.lstrip()
        if not s:
            return 0
        # s contain sign, determine sign and start from second char
        sign = 1
        if s[0] in '+-':
            sign = 1 if s[0] == '+' else -1
            s = s[1:]
        res = 0
        for c in s:
            # c may not be a int
            if c.isdigit():
                res = res * 10 + int(c)
            # if not int, whole string is invalid
            else:
                break
        res *= sign
        # check overflow
        if res < 0:
            res = max(-2**31, res)
        else:
            res = min(2**31-1, res)
        return res
```

这道题难点在于 corner cases：

1. s 为空 return 0 
2. s 只含有spaces strip后 check return 0
3. s[0] 为正负号 拿到sign后 s=s[1:]
4. overflow check

---

### 9. Palindrome Number

```
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        s = [x for x in str(x)]
        if len(s) == 1:
            return True
        l, r = 0, len(s) - 1
        while l <= r:
            if s[l] == s[r]:
                l += 1
                r -= 1
            else:
                return False
        return True
```

while loop 可以替换成 

        if s == s[::-1]:
            return True
---

### 10. Regular Expression Matching（Hard）

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        lenS, lenP = len(s), len(p)
        dp = [[False]*(lenP+1) for i in range(lenS+1)]
        dp[0][0] = True
        # case '' a*
        # initialize dp[0][j]
        for i in range(1,lenP + 1):
            if p[i - 1] == '*' and dp[0][i-2]:
                dp[0][i] = True
        for i in range(1, lenS+1):
            for j in range(1, lenP+1):
                if s[i-1] == p[j-1] or p[j-1] == '.':
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == '*':
                    # treat * like delete 
                    #e.g. ab d* remove d*
                    if p[j-2] != s[i-1] and p[j-2] != '.':
                        dp[i][j] = dp[i][j-2]
                    #case 1: ac ab*c remove b*   j-2
                    #p的前一个元素没有匹配上s当前元素的话 看看p的前两个元素匹配不，相当于把 *前面的元素删掉
                    
                    #case 2: ac ac* j-1
                    #p的前一个元素匹配了s当前元素的话 加上*也肯定匹配
                    
                    #case 3: a a* multiple a
                    #aa a* 首先确定了s的第二个a match上了 那就看第一个a能否match上 如果可以的话 整个也match了
                    # aaaa 和 a* s[i-1]先拿掉s最后一个a 然后抵消掉p中的一个a 去看剩下的能不能匹配
                    else:
                        dp[i][j] = dp[i][j-2] or dp[i][j-1] or dp[i-1][j]
                        
        return dp[-1][-1]
    
    #O(mn)
            
```

---

### 11. Container With Most Water

```
class Solution:
    def maxArea(self, height: List[int]) -> int:
        width = len(height) - 1
        l, r = 0, len(height) - 1
        res = 0
        while l < r:
            if height[l] < height[r]:
                area = height[l] * width
                l += 1
            else:
                area = height[r] * width
                r -= 1
            width -= 1
            res = max(res, area)
        return res
  # width 可以替换成 r- l 
```

two pointer 水的面积由最短的边决定 取完值后 移动最短的边向中心

---

### 12. Integer to Roman

```
class Solution:
    def intToRoman(self, num: int) -> str:
        d = {'M': 1000, 'CM': 900, 'D': 500, 'CD': 400, 'C': 100, 'XC': 90, 'L': 50, 'XL': 40, 'X': 10, 'IX': 9, 'V': 5, 'IV': 4, 'I': 1}
        res = []
        for k, v in d.items():
            while num >= v:
                num -= v
                res.append(k)
        return "".join(res)

```

---

### 13. Roman to Integer

```
loop 顺着来
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        res = 0
        for i in range(len(s) - 1):
            if d[s[i]] < d[s[i+1]]:
                res -= d[s[i]]
            else:
                res += d[s[i]]
        res += d[s[-1]]
        return res

class Solution:
    def romanToInt(self, s: str) -> int:
        d = {}
        d['I'] = 1
        d['V'] = 5
        d['X'] = 10
        d['L'] = 50
        d['C'] = 100
        d['D'] = 500
        d['M'] = 1000
        
        res = 0
        prev = 0
        for i in range(len(s)-1, -1, -1):
            v = d[s[i]]
            if v < prev:
                res -= v
            else:
                res += v
            prev = v
        return res
```

从后往前 如果后面一个数小于前面那个就减掉

---

### 14. Longest Common Prefix

```
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ''
        
        for i in range(len(strs[0])):
            ch = strs[0][i]
            for j in range(1, len(strs)):
                if i == len(strs[j]) or strs[j][i] != ch:
                    return strs[0][:i]
        
        return strs[0]
        
        
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ''
        strs = sorted(strs, key = lambda x: len(x))
        res = strs[0]
        for i in range(1, len(strs)):
        #res = '' 会自动exit
            while strs[i].find(res) != 0:
                res = res[:-1]
        return res        
```

先假设第一个string 为答案 然后loop这个string的character inner loop 剩下的string 如果遇到

1. 当前string的长度等于 第一个string 返回， 因为没必要继续
2. 当前string的相同位置不match， 返回 第一个string [:i]

---

### 15. 3Sum

```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        if len(nums) < 3:
            return []
        res = []
        nums.sort()
        for i in range(len(nums)-2):
            if i != 0 and nums[i] == nums[i-1]:
                continue
            j, k = i+1, len(nums) - 1
            while j < k:
                sum_ = nums[i] + nums[j] + nums[k]
                if sum_ == 0:
                    res.append([nums[i], nums[j], nums[k]])
                    while j < k and nums[j] == nums[j+1]:
                        j += 1
                    while j < k and nums[k] == nums[k-1]:
                        k -= 1
                    j += 1
                    k -= 1
                elif sum_ < 0:
                    j += 1
                else:
                    k -= 1
        return res
```

这道题要注意 not duplicate 

1. check 每一次nums[i] 和nums[i-1]
2. 当sum == 0的时候 check nums[j] 和nums[j+1]， nums[k]和nums[k-1], 之后再 j+= 1, k-=1

---

### 16. 3Sum Closest

```
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        res, diff = 0, math.inf
        nums.sort()
        for i in range(len(nums) - 2):
            j, k = i+1, len(nums)-1
            while j < k: 
                sum_ = nums[i] + nums[j] + nums[k]
                if sum_ == target:
                    return target
                elif abs(sum_ - target) < diff:
                    res = sum_
                    diff = abs(sum_ - target)

                if sum_ > target:
                    k -= 1
                else:
                    j += 1
        return res
```

同15

---

### 17. Letter Combinations of a Phone Number

```
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        res = [""]
        buttons = ["0", "1", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        for digit in digits:
            letters = buttons[int(digit)]
            temp = []
            for word in res:
                for c in letters:
                    temp.append(word + c)
            res = temp
        return res
    
    #O(4^n) wxyz 4 choices for each digit
```

这题也可以用backtracking

```
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        d = { "2": "abc", "3": "def", "4":"ghi", "5":"jkl", "6":"mno", "7":"pqrs", "8":"tuv", "9":"wxyz"}
        res = []
        self.dfs(digits, d, 0, '', res)
        return res
    
    def dfs(self, digits, d, i, path, res):
        if i == len(digits):
            res.append(path)
            #这里一定要return
            return
        v = d[digits[i]]
        for c in v:
            self.dfs(digits, d, i+1, path+c, res)
```



---

### 18. 4Sum

```
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        if len(nums) < 4:
            return []
        nums.sort()
        res = []
        for i in range(len(nums)-3):
            if i != 0 and nums[i] == nums[i-1]:
                continue
            j = i + 1
            for j in range(i+1, len(nums)-2):
                if j != i+1 and nums[j] == nums[j-1]:
                    continue
                p, q = j+1, len(nums)-1
                while p < q:
                    sum_ = nums[i]+nums[j]+nums[p]+nums[q]
                    if sum_ == target:
                        res.append([nums[i], nums[j], nums[p], nums[q]])
                        while p < q and nums[p] == nums[p+1]:
                            p += 1
                        while p < q and nums[q] == nums[q-1]:
                            q -= 1
                        p += 1
                        q -= 1
                    elif sum_ < target:
                        p += 1
                    else:
                        q -= 1
        return res
```

比起3sum  这里还需要check j的重复 when j != i+1

---

### 19. Remove Nth Node From End of List

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        slow, fast = head, head
        for _ in range(n):
            fast = fast.next
        if not fast:
            return head.next
        while fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return head
```

如果fast 是none 说明删掉的是head return head.next

while fast.next 让fast到最后一个node时候停止，这样刚好slow的下一个就是要删除的元素

---

### 20. Valid Parentheses

```
class Solution:
    def isValid(self, s: str) -> bool:
        if len(s) <= 1:
            return False
        stack = []
        for c in s:
            if c == '(':
                stack.append(')')
            elif c == '[':
                stack.append(']')
            elif c == '{':
                stack.append('}')
            else:
                if not stack or stack[-1] != c:
                    return False
                stack.pop()
        return not stack
```

用一个stack 遇到前括号 push 后括号 如果遇到后括号 当前stack 为空 或者最后一个不是当前后括号 就返回false

如果最后stack是空，说明所有的括号都match上了 都pop掉了

---

### 21. Merge Two Sorted Lists

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        if not l2:
            return l1
        dummy = ListNode(-1)
        curr = dummy
        while l1 and l2:
            if l1.val < l2.val:
                curr.next = l1
                l1 = l1.next
            else:
                curr.next = l2
                l2 = l2.next
            curr = curr.next
        if l1:
            curr.next = l1
        if l2:
            curr.next = l2
        return dummy.next
```

---

### 22. Generate Parentheses *

```
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        res = []
        #n, left, right, curr, result
        self.backtrack(n, 0, 0, "", res)
        return res
    
    '''
    	- opening should always be <=n. In this case we can always add another opening
	- closing should always be <=n and, thus, <= opening. In this case we can always add another closing
    '''
    def backtrack(self, n, left, right, current, res):
        if len(current) == n * 2:
            res.append(current)
            return
        if left < n:
            self.backtrack(n, left + 1, right, current + '(', res)
        # avoid )(
        if right < left:
            self.backtrack(n, left, right + 1, current + ')', res)
            
            #2^(2n) there are 2n position each position has 2 choices
            #space O(n)
```

backtrack, 难点 left< n 持续加左括号 ，right < left 加右括号

---

### 23. Merge k Sorted Lists (Hard) *

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        ListNode.__eq__ = lambda self, other: self.val == other.val
         # less than
        ListNode.__lt__ = lambda self, other: self.val < other.val
       
        minHeap = []
        for l in lists:
            if l is not None:
                heappush(minHeap, l)
        dummy = ListNode(-1)
        curr = dummy
        while minHeap:
            node = heappop(minHeap)
            curr.next = node
            if node.next:
                heappush(minHeap, node.next)
            curr = curr.next
        return dummy.next
                
```

---

### 24. Swap Nodes in Pairs *

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        curr = dummy
        while curr.next and curr.next.next:
            first = curr.next
            second = curr.next.next
            first.next = second.next
            second.next = first
            curr.next = second
            curr = first
        return dummy.next
```

root->1->2->3->4

curr 最开始在root上，first :1, second: 2

first.next = second.next : root->1->3->4

second.next = first: root->1->3->4, 2->1

curr.next = second: root->2->1->3->4

curr = first, curr现在在1上 然后继续 3->4的reverse

---

### 25. Reverse Nodes in k-Group (Hard) *

```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    '''
     dummy record head
     jump responsible for connection
      r is the second group's first element
      l is the first element of first group
    '''
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode:
        dummy = jump = ListNode(-1)
        dummy.next = l = r = head
        
        while True:
            count = 0
            while r and count < k:
                count += 1
                r = r.next
            if count == k:
                pre, cur = r, l
                for _ in range(k):
                    temp = cur.next
                    cur.next = pre
                    pre = cur
                    cur = temp
                jump.next = pre
                jump = l
                l = r
            else:
                return dummy.next
            
    '''
    dummy = jump = -1
    jump = -1
    l, r = dummy.next = head
    dummy(jump) -> head(l, r)
    -1          ->  1,2,3,4,5
    k = 2
    1. count = 0
       
       r = 3
       count = 2
       pre = 3
       cur = 1
       
        origin 1-2-3
        2-1-3
        pre = 2
        l = 3
        
      jump->pre(2)
      dummy->2-1-3
      jump = l = 1
      l = 3

    '''
```

jump 代表root 每一次revert完 jump.next 指向pre，jump跳到l去，也就是下一组需要revert的前面一个，l跳到人去， 也就是下一组要revert的首位

---

### 26. Remove Duplicates from Sorted Array

```
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        l = 1
        for r in range(1, len(nums)):
            if nums[r] != nums[r-1]:
                nums[l] = nums[r]
                l += 1
        return l
```

---

### 27. Remove Element

```
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        l = 0
        for r in range(len(nums)):
            if nums[r] != val:
                nums[l] = nums[r]
                l += 1
        return l
```

---

### 28. Implement strStr()

```
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle in haystack:
            return haystack.index(needle)
        else:
            return -1
```

---

### 29. Divide Two Integers

```
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        positive = (dividend < 0) is (divisor < 0)
        dividend, divisor = abs(dividend), abs(divisor)
        res = 0
        while divisor <= dividend:
            temp, mul = divisor, 1
            while dividend >= temp << 1:
                temp <<= 1
                mul <<= 1
            res += mul
            dividend -= temp
        if positive:
            return min(2**31-1, res)
        else:
            return max(-2**31, -res)

    '''
    19/3 = 3*2^1 + 3*2^2 + 1
    result = 2^1 + 2^2
    Time: O(logn * logn)
    Space: O(1)
    exponential search to find the biggest number fit into current dividend
    each while loop use logn 
    '''
```

---

### 30.Substring with Concatenation of All Words

```
class Solution:
    def findSubstring(self, s: str, words: List[str]) -> List[int]:
        d = Counter(words)
        wordLen = len(words[0])
        totalLen = wordLen * len(words)
        res = []
        for i in range(len(s)-totalLen+1):
            seen = defaultdict(int)
            for j in range(i, i+totalLen, wordLen):
                curr = s[j:j+wordLen]
                if curr in d:
                    seen[curr] += 1
                    if seen[curr] > d[curr]:
                        break
                else:
                    break
            if seen == d:
                res.append(i)
        return res
```

loop s, 长度为len(s) - totalLen+1, 长度小于totalLen的话没必要再loop

inner loop 当前的位置， 每次增加word的长度，一直到i+totalLen 

e.g foobarthebarfoo, i=第一个f, curr = foo， 查看curr是否在d里面，并且数量不要超过d（超过说明多了，break） 查完后 i = b（第二个bar)

inner loop完后 看seen是否等于d

---

### 31. Next Permutation

```
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        i = len(nums) - 2
        while i >= 0 and nums[i] >= nums[i+1]:
            i -= 1
        if i == -1:
            return nums.reverse()
        j = len(nums)-1
        while j > i and nums[j] <= nums[i]:
            j -= 1
        nums[i],nums[j] = nums[j], nums[i]
        l, r = i+1, len(nums)-1
        while l < r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
```

1. 从右往左 找到第一个小于他右边的index

如果index为-1 说明整个array已经被reverse掉了 直接返回reverse（）

2. 从右往左 找到第一个大于第一步找到的数，交换他们两个的位置

3. reverse 从第一步的index+1到最后

---

### 32. Longest Valid Parentheses (Hard) *

```
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        res, start, stack = 0, -1, []
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                if not stack:
                    start = i
                else:
                    stack.pop()
                    if not stack:
                        #case )()())
                        res = max(res, i - start)
                    else:
                       #case (()
                       # stack[-1] 相当与start
                        res = max(res, i - stack[-1])
        return res
                    
```

if not stack: start = i 这里是因为invalid restart，不能让后面 i-start 因为第一个不是valid 不能 )(()) 到最后一个的时候是4 -（-1） = 5。因为第一个是invalid的

start 一开始 = -1 因为 如果都符合 i+1才是string 的长度

也有从新开始的意思

---

### 33. Search in Rotated Sorted Array

```
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums)-1
        while l <= r:
            mid = l + (r-l)//2
            if nums[mid] == target:
                return mid
             # 这里 >= 是因为在case [3,1] 中 mid == l的， 因为 (r-l)//2 是向下取整的， 所以要考虑
            if nums[mid] >= nums[l]:
                if target >= nums[l] and target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            else:
                if target > nums[mid] and target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
        return -1
        
 l + 1 < r method       
        
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums:
            return [-1,-1]
        left, right = self.searchLeft(nums, target), self.searchRight(nums,target)
        return [left, right]
    
    def searchLeft(self, nums, target):
        l, r = 0, len(nums) - 1
        while l + 1 < r:
            mid = l + (r-l) // 2
            if nums[mid] == target:
                r = mid
            elif nums[mid] < target:
                l = mid
            else:
                r = mid
        if nums[l] == target:
            return l
        elif nums[r] == target:
            return r
        else:
            return -1
        
    
    def searchRight(self, nums, target):
        l , r = 0, len(nums) - 1
        res = -1
        while l + 1 < r:
            mid = l + (r-l) // 2
            if nums[mid] == target:
                l = mid
            elif nums[mid] < target:
                l = mid 
            else:
                r = mid
        if nums[r] == target:
            return r
        elif nums[l] == target:
            return l
        else:
            return -1
        
```

注意等号的使用

---

### 34. Find First and Last Position of Element in Sorted Array

```
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left, right = self.searchLeft(nums, target), self.searchRight(nums, target)
        return [left, right]
        
    def searchLeft(self, nums, target):
        l, r = 0, len(nums)-1
        res = -1
        while l <= r:
            mid = l + (r-l)//2
            if nums[mid] == target:
                res = mid
                r = mid - 1
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        return res
    
    def searchRight(self, nums, target):
        l, r = 0, len(nums)-1
        res = -1
        while l <= r:
            mid = l + (r-l)//2
            if nums[mid] == target:
                res = mid
                l = mid + 1
            elif nums[mid] < target:
                l = mid + 1
            else:
                r = mid - 1
        return res
```

两个search的区别在于 if nums[mid] == target

在searchLeft的时候 意味着start可能在mid也可能在mid之前所以将r = mid -1 再往左边看看

在searchRight的时候 意味着end可能是mid 也可能在mid 之后 所以 l = mid + 1 再往右边看看

---

### 35. Search Insert Position

```
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        for i in range(len(nums)):
            if nums[i] == target or nums[i] > target:
                return i
        return len(nums)
#二分

class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l + 1 < r:
            mid = l + (r-l)//2
            if nums[mid] < target:
                l = mid
            elif nums[mid] > target:
                r = mid
            else:
                return mid
        if nums[r] < target:
            return r+1
        elif nums[l] >= target:
            return l
         # 剩下的就是 targe <= nums[r]
        return r
```

---

### 36. Valid Sudoku

```
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        row, col, box = defaultdict(list), defaultdict(list), defaultdict(list)
        for i in range(9):
            for j in range(9):
                c = board[i][j]
                if c != '.':
                    if (c in row[i]) or (c in col[j]) or (c in box[(i//3, j//3)]):
                        return False
                    row[i].append(c)
                    col[j].append(c)
                    box[(i//3, j//3)].append(c)
        return True
```

这道题 我一开始想的是去check每一个character 的row， col， box 但其实应该先处理这个board，拿到row， col，box

再有一点就是 boxIndex = (i//3) * 3 + j//3

----

### 37. Sudoku Solver

```
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        rows, cols, boxes = defaultdict(set), defaultdict(set), defaultdict(set)
        visited = deque([])
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    rows[i].add(board[i][j])
                    cols[j].add(board[i][j])
                    boxes[(i//3, j//3)].add(board[i][j])
                else:
                    visited.append((i, j))
        def dfs():
            if not visited:
                return True
            r, c = visited[0]
            t = (r//3, c//3)
            for n in '123456789':
                if n not in rows[r] and n not in cols[c] and n not in boxes[t]:
                    board[r][c] = n
                    rows[r].add(n)
                    cols[c].add(n)
                    boxes[t].add(n)
                    visited.popleft()
                    if dfs():
                        return True
                    else:
                        board[r][c] = '.'
                        rows[r].discard(n)
                        cols[c].discard(n)
                        boxes[t].discard(n)
                        visited.appendleft((r,c))
            return False
        dfs()
```

首先处理board like 36, 并且把 空的空格加入到visit里面

dfs(), 从visit[0] 开始 填入1-9，每一次填入后 check dfs（）是否return True, 不是的话说明该数字不能填入就需要重置该格为'.'， 并且discard掉刚刚填入的数字

**这里没有visited.popleft() 因为如果dfs() return了 false 这个(r,c) 就不能再使用了 换成别的数字 (被pop掉了)**



### 38. Count and Say

```
class Solution:
    def countAndSay(self, n: int) -> str:
        res = '1'
        for i in range(n - 1):
            res = self.getNext(res)
        return res
    
    def getNext(self, seq):
        i, next_seq = 0, ''
        while i < len(seq):
            count = 1
            while i < len(seq) - 1 and seq[i] == seq[i+1]:
                count += 1
                i += 1
            next_seq += str(count) + seq[i]
            i += 1
        return next_seq
```

recursive 第一个是'1', 然后getNext() 里面有两个while loop 不用for的原因是，不是要loop每一个characer， 所以这里找到相同的character就直接i+1

---

### 39. Combination Sum

```
class Solution:
    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:
        res = []
        self.dfs(nums, target, 0, [], res)
        return res
    
    def dfs(self, nums, target, index, path, res):
        if target < 0:
            return
        if target == 0:
            res.append(path)
            return
        for i in range(index, len(nums)):
            self.dfs(nums, target - nums[i], i, path + [nums[i]], res)
```

backtrack, 注意这题跟40题的区别 这里的index i 是不变的，也不需要sort

---

### 40. Combination Sum II

```
class Solution:
    def combinationSum2(self, nums: List[int], target: int) -> List[List[int]]:
        res = []
        nums.sort()
        self.dfs(nums, target, 0, [],res)
        return res
    
    def dfs(self, nums, target, index, path, res):
        if target < 0:
            return 
        if target == 0:
            res.append(path)
        for i in range(index, len(nums)):
            if i != index and nums[i] == nums[i-1]:
                continue
              # diff 40, i+1
            self.dfs(nums, target - nums[i], i+1, path + [nums[i]], res)
```

---

### 41. First Missing Positive

```
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        i = 0
        while i < len(nums):
            j = nums[i]-1
            if 0 < nums[i] < len(nums) and nums[i] != nums[j]:
                nums[i], nums[j] = nums[j], nums[i]
            else:
                i += 1
        for i in range(len(nums)):
            if nums[i] != i+1:
                return i+1
        return len(nums) + 1
```

需要注意的点

1. 首位是从1开始 [1,2,3...], 所以 j = nums[i]-1, 从0开始就不用-1
2. if 0 < nums[i] < len(nums), 要小于len(nums). 如果 没有这个条件 [7,8,9,11,12], len(nums) = 5, j = nums[0] - 1 = 6, nums[6] 会报错

---

### 42. Trapping Rain Water

```
class Solution:
    def trap(self, h: List[int]) -> int:
        l, r = 0, len(h) - 1
        res, maxLeft, maxRight = 0, -math.inf, -math.inf
        while l < r:
            if h[l] < h[r]:
                maxLeft = max(maxLeft, h[l])
                res += maxLeft - h[l]
                l += 1
            else:
                maxRight = max(maxRight, h[r])
                res += maxRight - h[r]
                r -= 1
        return res
```

往低的那边灌水

---

### 43. Multiply Strings

```
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        return str(self.toInt(num1) * self.toInt(num2))
    
    def toInt(self, n):
        res, step = 0, 1
        for c in n[::-1]:
            res += step * int(c)
            step *= 10
        return res
```

---

### 44. Wildcard Matching (Hard, DP) *

```
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        lenS, lenP = len(s), len(p)
        dp = [[False]*(lenP+1) for i in range(lenS+1)]
        dp[0][0] = True
        #special case "aa" "*"
        for j in range(1, lenP+1):
            if p[j-1] == '*' and dp[0][j-1]:
                dp[0][j] = True
        for i in range(1, lenS+1):
            for j in range(1, lenP+1):
                if s[i-1] == p[j-1] or p[j-1] == '?':
                    dp[i][j] = dp[i-1][j-1]
                elif p[j-1] == '*':
                    #trea as 0 or many
                    dp[i][j] = dp[i][j-1] or dp[i-1][j]
        return dp[-1][-1]
```

44比起10 要简单一点 在于最后一个elif 只需要看是否是 * 

如果是* 两种情况 1. 当成空处理 看j的前一个 j-1和i， 2. 当成多个字符处理 i的前一个和当前j 因为如果i前面i-1的都能匹配上 i肯定也能匹配了

---

### 45. Jump Game II

```
class Solution:
    def jump(self, nums):
        if len(nums) <= 1: return 0
        l, r = 0, nums[0]
        times = 1
        while r < len(nums) - 1:
            times += 1
            nxt = max(i + nums[i] for i in range(l, r + 1))
            l, r = r, nxt
        return times
    
    '''
    [l,r] range represent the range it can reach, so after each iteration
    l change to the prev farest which is r, and r change to the maximum 
    '''
```

---

### 46. Permutations

```
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        self.dfs(nums, [False] * len(nums), [], res)
        return res
    
    def dfs(self, nums, used, path, res):
        if len(path) == len(nums):
            res.append(path)
            return
        for i in range(len(nums)):
            if not used[i]:
                used[i] = True
                self.dfs(nums, used, path+[nums[i]], res)
                used[i] = False
```

### 47. Permutations II

```
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        nums.sort()
        self.dfs(nums, [False] * len(nums), [], res)
        return res
    
    def dfs(self, nums, used, path, res):
        if len(path) == len(nums):
            res.append(path)
            return
        for i in range(len(nums)):
            if not used[i]:
                if i > 0 and not used[i-1] and nums[i] == nums[i-1]:
                    continue
                used[i] = True
                self.dfs(nums, used, path+[nums[i]], res)
                used[i] = False
```

**记得排序**

---

### 48. Rotate Image

```
class Solution:
    def rotate(self, m: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        size = len(m)
        for i in range(size):
            for j in range(i, size):
                m[i][j], m[j][i] = m[j][i], m[i][j]
        for i in range(size):
            m[i].reverse()
```

注意 j是（1，size）, 如果j 也是range(size) 整个row 就不会变了

---

### 49. Group Anagrams

```
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        res = []
        d = defaultdict(list)
        for w in strs:
            key = sorted(w)
            d[tuple(key)].append(w)
        return d.values()
```

1. 只有tuple 能用来当key, immutable 
2. string 不能 .sort() 只能 sorted(w)

---

### 50. Pow(x, n)

```
class Solution:
    def myPow(self, x: float, n: int) -> float:
        '''
O(logb)
> Base Case:  b == 0
> Function: F(a ^ b) = F(a ^ b // 2) *  F(a ^ b // 2)
不论我们返回时候如何，我们执行第一步，先设立Base Case:
if b == 0: return 1

完了以后，我们要对大问题进行拆分，也就是不断的对b的值折半

拆分：
half = self.myPow(a, b // 2)

当拆分到了最小的问题，满足base case b == 0 的时候，我们则进行返回，返回时候有三种可能

Function的三种可能性：

当b为偶数的时候，比如 2 ^ 100，拆分的时候就变成 (2 ^ 50) * (2 ^ 50)
当b为基数的时候，比如 2 ^ 25，拆分的时候就变成 (2 ^12) * (2 ^ 12) * 2
当b为负数的时候，返回 1.0 / self.myPow(a, -b)
'''
        if n == 0:
            return 1
        if n < 0:
            return 1.0 / self.myPow(x, -n)
        half = self.myPow(x, n // 2)
        if n % 2 == 0:
            return half * half
        else:
            return half * half * x
        
        '''
        Input: x = 2, n = 10
        
        1.
        half = myPow(2, 5)
            half = myPow(2, 2)
                half = myPow(2, 1)
                    half = mypow(2,0) -> return 1
        
        2. 
        half = 1
        1 % 2 = 1 != 0
        return 1 * 1 * 2 = 2
        
        3. 
        half = 2
        2 % 2 == 0
        return 2 * 2 = 4
        
        4.
        half = 4
        5 % 2 != 0
        return 4 * 4 * 2 = 32
        
        5. half = 32
        10 % 2 == 0
        return 32 * 32 =  1024
                
        '''

```

---

### 51. N-Queens (Hard) *

```python
class Solution:
    def solveNQueens(self, n):
        res = []
        self.dfs([-1]*n, 0, [], res)
        return res

    # nums is a one-dimension array, like [1, 3, 0, 2] means
    # first queen is placed in column 1, second queen is placed
    # in column 3, etc.
    def dfs(self, nums, index, path, res):
        if index == len(nums):
            res.append(path)
            return  # backtracking
        for i in range(len(nums)):
            nums[index] = i
            if self.valid(nums, index):  # pruning
                tmp = "."*len(nums)
                self.dfs(nums, index+1, path+[tmp[:i]+"Q"+tmp[i+1:]], res)

    # check whether nth queen can be placed in thrat column
    def valid(self, nums, n):
        for i in range(n):
          # abs(nums[i]-nums[n]) 说明 第一个q放在第一个row第一个col， 第二个q放在第二个row的第二个col
          # invalid
            if abs(nums[i]-nums[n]) == n -i or nums[i] == nums[n]:
                return False
        return True
```

---

### 52. N-Queens II

```
class Solution:
    def totalNQueens(self, n: int) -> List[List[str]]:
        res = []
        self.dfs([-1]*n, 0, [], res)
        return len(res)
    
    def dfs(self, nums, index, path, res):
        if index == len(nums):
            res.append(path)
            return
        for i in range(len(nums)):
            nums[index] = i
            if self.valid(nums, index):
                temp = '.'*len(nums)
                self.dfs(nums, index+1, path+[temp[:i]+'Q'+temp[i+1:]], res)
                
    def valid(self, nums, index):
        for i in range(index):
            if abs(nums[i]-nums[index]) == abs(i-index) or nums[i] == nums[index]:
                return False
        return True
```

同51

---

### 53. Maximum Subarray

```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res, curr = nums[0], nums[0]
        for n in nums[1:]:
            curr = max(n, curr + n)
            res = max(curr, res)
        return res
```

---

### 54. Spiral Matrix

```
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []
        m, n = len(matrix), len(matrix[0])
        seen = [[False] * n for _ in matrix]
        dr = [0, 1, 0, -1]
        dc = [1, 0, -1, 0]
        r = c = di = 0
        res = []
        for _ in range(m * n):
            res.append(matrix[r][c])
            seen[r][c] = True
            cr, cc = r + dr[di], c + dc[di]
            if 0 <= cr < m and 0 <= cc < n and not seen[cr][cc]:
                r, c = cr, cc
            else:
                di = (di + 1) % 4
                r, c = r + dr[di], c + dc[di]
        return res
    
    '''
    res = [1,2,3]
    di = 1 % 4 = 1
    dr[di] = 1, dc[di] = 0 row increase by 1
    res = [1,2,3,6,9]
    
    di = 2 % 4 = 2
    dr[di] = 0, dc[di] = -1 col decrease by 1
    res = [1,2,3,6,9,8,7]
    
    '''
```

---

### 54. Spiral Matrix

```
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if not matrix:
            return []
        m, n = len(matrix), len(matrix[0])
        visited = [[False] * n for _ in range(m)]
        dr = [0, 1, 0, -1]
        dc = [1, 0, -1, 0]
        r = c = di = 0
        res = []
        for _ in range(m*n):
            res.append(matrix[r][c])
            visited[r][c] = True
            rr, cc = r + dr[di], c + dc[di]
            if 0 <= rr < m and 0 <= cc < n and not visited[rr][cc]:
                r, c = rr, cc
            else:
                di = (di+1) % 4
                r, c = r + dr[di], c + dc[di]
        return res
```

---

### 55. Jump Game

```
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        maxIndex = 0
        for i, v in enumerate(nums):
            if i > maxIndex:
                return False
            maxIndex = max(maxIndex, i + v)
        return True
```

---

### 56. Merge Intervals

```
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if len(intervals) <= 1:
            return intervals
        intervals = sorted(intervals, key = lambda x: x[0])
        res = []
        start, end = intervals[0]
        
        for i in range(1, len(intervals)):
            if intervals[i][0] <= end:
                end = max(end, intervals[i][1])
            else:
                res.append([start, end])
                start = intervals[i][0]
                end = intervals[i][1]
        res.append([start, end])
        return res
```

---

### 57. Insert Interval

```
class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -> List[List[int]]:
        if not intervals:
            return [newInterval]
        i, res = 0, []
        while i < len(intervals) and intervals[i][1] < newInterval[0]:
            res.append(intervals[i])
            i += 1
        while i < len(intervals) and intervals[i][0] <= newInterval[1]:
            newInterval[0] = min(newInterval[0], intervals[i][0])
            newInterval[1] = max(newInterval[1], intervals[i][1])
            i += 1
        res.append(newInterval)
        while i < len(intervals):
            res.append(intervals[i])
            i += 1
        return res
```

---

### 58. Length of Last Word

```
class Solution:
    def lengthOfLastWord(self, s: str) -> int:
        words = s.split(' ')
        words = [x for x in words if len(x) >= 1]
        if not words:
            return 0
        return len(words[-1])
```

---

### 59. Spiral Matrix II

```
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        dr, dc = [0, 1, 0, -1], [1, 0, -1, 0]
        res = [[0] * n for _ in range(n)]
        seen = [[False] * n for _ in range(n)]
        r, c, di = 0, 0, 0
        for i in range(1, n**2+1):
            res[r][c] = i
            seen[r][c] = True
            rr, cc = r + dr[di], c + dc[di]
            if 0 <= rr < n and 0 <= cc < n and not seen[rr][cc]:
                r, c = rr, cc
            else:
                di = (di+1)%4
                r, c = r + dr[di], c + dc[di]
        return res
```

---

### 60. Permutation Sequence (Hard) *

```
class Solution:
    def getPermutation(self, n, k):
        res, nums = "", [x for x in range(1, n + 1)]
        k -= 1
        while n:
            n -= 1
            index, k = divmod(k, factorial(n))
            res += str(nums.pop(index))
        return res


'''
for n there are factorial(n)
say n = 4, you have {1, 2, 3, 4}
If you were to list out all the permutations you have
1 + (permutations of 2, 3, 4)

2 + (permutations of 1, 3, 4)

3 + (permutations of 1, 2, 4)

4 + (permutations of 1, 2, 3)

14th one 13/6(3!) = 2 -> first digit 3
'''
```

---

### 61. Rotate List

```
# Definition for singly-linked list.
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        if not head:
            return None
        last = head
        size = 1
        while last.next:
            last = last.next
            size += 1
        last.next = head
        k = k % size
        temp = head
        for _ in range(size-k-1):
            temp = temp.next
        res = temp.next
        temp.next = None
        return res
```

注意那个size = 1 因为while是到last.next结束 所以 如果size = 0的话会少算一个

---

### 62. Unique Paths dp

```
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        dp = [[1]*n for _ in range(m)]
        for i in range(1, m):
            for j in range(1, n):
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

dp[i-1] [j] 就是在上一排同一个col的步数 dp[i] [j-1] 就是同一排的左边 因为题目要求只能向下和向右 就考虑这两个就可以了

---

### 63. Unique Paths II  dp

```
class Solution:
    def uniquePathsWithObstacles(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [[0]*n for _ in range(m)]
        for i in range(m):
            if grid[i][0] == 1:
                break
            dp[i][0] = 1
        for i in range(n):
            if grid[0][i] == 1:
                break
            dp[0][i] = 1
        for i in range(1, m):
            for j in range(1, n):
                if grid[i][j] == 1:
                    continue
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
        return dp[-1][-1]
```

与62 不同的是 先得考虑第一排的 第一列出现石头的情况

---

### 64. Minimum Path Sum dp

```
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m = len(grid)
        n = len(grid[0])
        for i in range(1, n):
            grid[0][i] += grid[0][i - 1]
        for i in range(1, m):
            grid[i][0] += grid[i - 1][0]
        for i in range(1, m):
            for j in range(1, n):
                grid[i][j] += min(grid[i][j - 1], grid[i - 1][j])
        return grid[-1][-1]
```

---

### 65. Valid Number(Hard) *

```
class Solution:
    def isNumber(self, s: str) -> bool:
        s = s.lower().replace('+','-').strip()
        if not s: 
            return False
        # 5. is valid
        if not (s[-1].isdigit() or s[-1] == '.'): 
            return False
        #.5 is valid
        if not (s[0].isdigit() or s[0] in '-.'): 
            return False
        if s[0] == '-': s = s[1:]
        s, p, e = s.replace('e-',''), s.find('.'), s.find('e')
        if 'e' in [s[0],s[-1]] or s.count('.') > 1 or s.count('e') > 1: 
            return False
        if s.isdigit():
            return True
        if len(s) <= 1:
            return False
        if any(c in s for c in 'abcdfghijklmnopqrstuvwxyz- '): 
            return False
        if s[:2] == '.e' or not (-1 in [e,p] or e > p): 
            return False
        return True
```

---

### 66. Plus One

```
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        res, carry, step = [], 0, 1
        for i in range(len(digits)-1, -1, -1):
            n = digits[i] * step + carry
            if i == len(digits) - 1:
                n += 1
            res.append(n % 10)
            carry = n // 10
        if carry:
            res.append(carry)
        res.reverse()
        return res 
```



### 67. Add Binary

```
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        i, j = len(a) - 1, len(b) - 1
        res, carry = [], 0
        while i >= 0 or j >= 0:
            x = int(a[i]) if i >= 0 else 0
            y = int(b[j]) if j >= 0 else 0
            sum_ = x + y + carry
            res.append(sum_ % 2)
            carry = sum_ // 2
            i -= 1
            j -= 1
        if carry:
            res.append(carry)
        res.reverse()
        return ''.join([str(x) for x in res])
```

---

### 69. Sqrt(x)

```
class Solution:
    def mySqrt(self, x: int) -> int:
        if x < 2:
            return x
        l, r = 2, x // 2
        while l + 1 < r:
            mid = l + (r-l)//2
            if mid ** 2 < x:
                l = mid
            elif mid ** 2 > x:
                r = mid
            else:
                return mid
        if r ** 2 <= x:
            return r
        else:
            return l
    
    #O(logn)
```

以后二分法 都写成l+1 < r 再根据条件判断l 和 r

---

### 70. Climbing Stairs

```
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 1:
            return 1
        if n == 2:
            return 2
        dp = [0] * (n+1)
        dp[0] = 0
        dp[1] = 1
        dp[2] = 2
        for i in range(3, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[-1]
```



